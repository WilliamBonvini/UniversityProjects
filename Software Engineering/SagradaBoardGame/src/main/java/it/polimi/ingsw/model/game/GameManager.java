package it.polimi.ingsw.model.game;

import it.polimi.ingsw.client.view.factories.ViewChoiceFactory;
import it.polimi.ingsw.connection.messages.server.*;
import it.polimi.ingsw.connection.server.ClientDispatcher;
import it.polimi.ingsw.connection.server.util.ClientContainer;
import it.polimi.ingsw.controller.FilterManager;
import it.polimi.ingsw.exceptions.CantAccessPlayerException;
import it.polimi.ingsw.exceptions.InvalidComponentException;
import it.polimi.ingsw.model.DiceContainer;
import it.polimi.ingsw.model.Die;
import it.polimi.ingsw.model.Table;
import it.polimi.ingsw.model.factories.TableFactory;
import it.polimi.ingsw.utils.Couple;
import it.polimi.ingsw.utils.Logger;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Represent a logical Game. Handle the control of a single match, from beginning to end, supported by other classes
 * to handle different aspects and phases of a game
 */
public class GameManager extends Thread {

    private Table table;
    private ClientContainer clientContainer;
    private boolean gameStarted;
    private Flow flow;
    private TurnManager turnManager;
    private ChooseBoardPhaseManager boardPhaseManager;
    private ScorePhaseManager scorePhaseManager;

    private int gameID;
    private boolean activeScores;

    private FilterManager filter;



    public GameManager (ClientContainer container) {
        gameID = 0;
        clientContainer = container;
        boardPhaseManager = new ChooseBoardPhaseManager(clientContainer.size(), this);
        scorePhaseManager = new ScorePhaseManager();
        gameStarted = false;
        turnManager = new TurnManager(this);
        filter = new FilterManager(this);
        activeScores = false;
    }

    public GameManager (ClientContainer container, int gameID) {
        clientContainer = container;
        boardPhaseManager = new ChooseBoardPhaseManager(clientContainer.size(), this);
        scorePhaseManager = new ScorePhaseManager();
        gameStarted = false;
        turnManager = new TurnManager(this);
        filter = new FilterManager(this);
        this.gameID = gameID;
        activeScores = false;
    }

    public FilterManager getFilter () {
        return filter;
    }

    public Table getTable() {
        return table;
    }

    public void setTable (Table table) {
        this.table = table;
    }

    /**
     * Notify that the current player is changed, or that a new turn is started for the same previous player
     */
    public void notifyPlayerChanged () {
        ChangedModelMessage message = new ChangedModelMessage(table, this);
        clientContainer.sendMessageToAll(message);
        turnManager.startNewTurn();
    }

    public void notifyChanged() {
        ChangedModelMessage message = new ChangedModelMessage(table, this);
        clientContainer.sendMessageToAll(message);
    }

    public ClientContainer getClientContainer() {
        return clientContainer;
    }

    /**
     * Starts the setup of the game: takes the boards used in game,
     * then asks to user which one they want,
     * then the game is started by the client handlers
     */
    @Override
    public void run() {
        try {
            //set up the boards for the players
            boardPhaseManager.setUpBoardsForUsers(clientContainer.getPlayersNames());

            //send messages to all users
            for (String player: clientContainer.getPlayersNames()) {
                //the message is generated by the boardPhaseManager
                clientContainer.sendMessageTo(player, boardPhaseManager.generateMessage(player));
            }
            Logger.std().info("ChooseBoard Messages sent, waiting for answers");

        } catch (IOException e) {
            Logger.std().error("Could not load boards from file! Match canceled");
            ClientDispatcher.instance().closeGame(this);
            clientContainer.sendMessageToAll(new GameEndedMessage());
        }

    }

    /**
     * Start a new Game. If this game is logically already gameStarted will do nothing
     */
    protected void startGame() {
        if(gameStarted)
            return;
        Logger.std().info("All reply arrived, starting game");
        table = TableFactory.createTable(boardPhaseManager.getUserBoardCouples());
        sendSetupMessages();
        flow = new Flow(this);
        flow.setupFlow();
        new Thread(flow).start();
        gameStarted = true;
        activeScores = true;
    }

    /**
     * notify that is time for the score phase
     */
    protected void notifyScorePhase() {
        if(activeScores)
            endGame(scorePhaseManager.calculateScores(table));
    }


    /**
     * Notify the game's end, and pass the list of players and their scores
     * @param playersAndScores
     */
    protected void endGame(List<Couple<String, Integer>> playersAndScores) {
        clientContainer.sendMessageToAll(new GameEndedMessage(playersAndScores, false));
        ClientDispatcher.instance().closeGame(this);
    }


    public void setFlow(Flow flow) {
        this.flow = flow;
    }

    public Flow getFlow() {
        return flow;
    }

    public TurnManager getTurnManager() {
        return turnManager;
    }

    public ChooseBoardPhaseManager getBoardPhaseManager() {
        return boardPhaseManager;
    }

    public int getGameID() {
        return gameID;
    }

    public void setGameID(int gameID) {
        this.gameID = gameID;
    }

    public boolean isGameStarted() {
        return gameStarted;
    }

    /**
     * notify the GameManager that a user went offline: it will check how many players are remaining,
     * eventually closing the game
     */
    public synchronized void notifySomeoneOffline(String player) {
        if(clientContainer.isIn(player)) {
            Logger.std().info("[GAME#"+gameID+"] "+player + " went offline.");
            //if only one player left, he wins the game
            if(clientContainer.howManyOnline() <=1) {
                if(flow != null)
                    flow.stop();

                if(clientContainer.howManyOnline() == 1) {
                    clientContainer.sendMessageTo(clientContainer.getOnlinePlayers().get(0),
                            new GameEndedMessage(new ArrayList<>(), true));

                }

                ClientDispatcher.instance().closeGame(this);

            } else if(!boardPhaseManager.hasFinishedPhase()) {
                boardPhaseManager.forceChoice(player);
                clientContainer.sendMessageToAll(new GeneralMessage(player + " e' uscito dalla partita!"));
            } else {//else blacklist every offline user for turn management
                turnManager.blacklist(clientContainer.getOfflinePlayers());
                //and notify others that the user went offline
                clientContainer.sendMessageToAll(new GeneralMessage(player + " e' uscito dalla partita!"));
            }
        }

    }


    /**
     * Notify that someone has relogged. This will not change its clientContainer's handlers
     * @param username
     */
    public synchronized void notifySomeoneRelog(String username) {
        if(boardPhaseManager.hasFinishedPhase()) {
            clientContainer.sendMessageTo(username, new SetupMessage(table, username));
            getTurnManager().returnActive(username);
            clientContainer.sendMessageTo(username, new ChangedModelMessage(table, this));

            GeneralMessage infoMessage = new GeneralMessage(username + " e' rientrato in partita!");
            clientContainer.sendMessageToAllExcept(infoMessage, username);
        } else {
            GeneralMessage infoMessage = new GeneralMessage(username + " e' rientrato in partita!");
            clientContainer.sendMessageToAllExcept(infoMessage, username);
        }

    }

    /**
     * Check if the specified player is logged in this game
     * @param player to be checked
     * @return true if the player is in this game
     */
    public boolean hasPlayer(String player) {
        return clientContainer.isIn(player);
    }


    private void sendSetupMessages() {
        for (String player: clientContainer.getPlayersNames()) {
            clientContainer.sendMessageTo(player, new SetupMessage(table, player));
            Logger.std().verbose("Sent Message setup to "+ player);
        }
    }

    /**
     *  This function return the specified container
     * @param name of the container
     * @return the appropriate DiceContainer or throw InvalidComponentException if there is no such container
     */
    public DiceContainer getDiceContainer (String name) {
        DiceContainer container;
        switch (name) {
            case "pool":
                container = getTable().getPool();
                break;
            case "roundtrack":
                container = getTable().getRoundTrack();
                break;
            case "current":
                container = getFlow()
                        .getMicroOperationVariables()
                        .getCurrentPlayer()
                        .orElseThrow(CantAccessPlayerException::new);
                break;
            case "board":
                container = getFlow()
                        .getMicroOperationVariables()
                        .getCurrentPlayer()
                        .orElseThrow(CantAccessPlayerException::new)
                        .getBoard();
                break;
            case "bag":
                container = getTable().getDiceBag();
                break;
            case "tool":
                container = new DiceContainer() {
                    @Override
                    public Die getDie(int idview) {
                        throw new UnsupportedOperationException();
                    }
                    @Override
                    public void setDie(int idview, Die die) {
                        throw new UnsupportedOperationException();
                    }
                    @Override
                    public void removeDie(int idview) {
                        throw new UnsupportedOperationException();
                    }
                    @Override
                    public List<Die> getAll() {
                        throw new UnsupportedOperationException();
                    }
                    @Override
                    public void addDie(Die die) {
                        throw new UnsupportedOperationException();
                    }
                    @Override
                    public void removeDie(Die die) {
                        throw new UnsupportedOperationException();
                    }
                    @Override
                    public int size() {
                        return 3;
                    }
                };
                break;
            case "choose":
                container = new ChooseContainer(this);
                break;
            default:
                Logger.std().error("getDiceContainer(): " + name + " is not a valid container");
                throw new InvalidComponentException();
        }
        return container;
    }
}

class ChooseContainer implements DiceContainer {
    private GameManager gm;
    ChooseContainer (GameManager gm) {
        this.gm = gm;
    }
    @Override
    public Die getDie(int idview) {
        throw new UnsupportedOperationException();
    }
    @Override
    public void setDie(int idview, Die die) {
        throw new UnsupportedOperationException();
    }
    @Override
    public void removeDie(int idview) {
        throw new UnsupportedOperationException();
    }
    @Override
    public List<Die> getAll() {
        throw new UnsupportedOperationException();
    }
    @Override
    public void addDie(Die die) {
        throw new UnsupportedOperationException();
    }
    @Override
    public void removeDie(Die die) {
        throw new UnsupportedOperationException();
    }
    @Override
    public int size() {
        return ViewChoiceFactory.getViewChoiceById(gm.getFlow().getMicroOperationVariables().getSchema()).getOptions().length;
    }
}